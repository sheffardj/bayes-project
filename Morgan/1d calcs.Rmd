---
title: "Untitled"
output: pdf_document
date: "2022-11-17"
---

$$
p(\sigma|x) = \frac{p(\sigma)p(x|\sigma)}{\int p(\sigma)p(x|\sigma)}\\

$$

Working with the logit normal we will first calculate the top of the fraction 
```{r}
library(logitnorm)
library(sn)
library(dplyr)
library(philentropy)
library(bayestestR)
library(ggplot2)
library(ggpubr)
```

# the priors 
```{r}
un <- function (d) {
  dunif(d, -1, 1)
  }
nor <- function (d){
  dnorm(d, 0, 1)
  }
bet <- function(d){
  dbeta(d, .5, .5)
}

sn <- function(d){
  dsn(d, .2,.2)
}


```

# funtion to out put the graph and estimates
```{r}
est.calc <- function(prior, s, u,t){
  set.seed(0)
  dat <- rlogitnorm(15000, 0, s) 
  
  simps_three8 <- function(f, a, b, n){
  # function f
  # [a,b] interval of integration
  # n = number of BIG subdivisions (will be multiplied by three to include middle ones)
  nn = 3*n+1
  h = (b - a)/n
  xx <- seq(a, b, length=nn)
  y = f(xx)
  
  h*( y[1] + y[nn] + 3*sum(y[(2:(nn-1))[2:(nn-1)%%3!=1]])  + 2*sum(y[(2:(nn-1))[2:(nn-1)%%3==1]]) )/8
  }
  
  sigma0 <- var(dat)
  
  tests <- function (x){
  dlogitnorm(dat, 0 , x)*prior(x)
  } 
  
  dnom <- simps_three8(tests, 0,1, 1000) 
  
  

  est <- mean((dlogitnorm(dat, 0, s)*prior(sigma0))/dnom)
  
  #KL Divergence
  truf <- plogitnorm(dat, 0, s)
  samp <- plogitnorm(dat, 0,  est)
  mat <- rbind(truf/sum(truf), samp/sum(samp))
  div <- KL(mat)
  
  #CI
  simp <- rlogitnorm(15000, 0, est)
  c <- ci(simp, ci = .95, method = 'HDI', verbose =F)
  
  #plots
  # hist(dat, probability = T, ylim = c(0,5))
  # curve(dlogitnorm(x, 0, s), col = 'red', add = T)
  # curve(dlogitnorm(x, 0, est), col ='blue', add = T)
  
ex <- matrix(dat, ncol=1)

colnames(ex) <- "x"

g <-ggplot(as.data.frame(ex), aes(x=x)) + 
  geom_histogram(aes(y=..density..),  color= 'lightblue') +
  stat_function( # orignal params
    fun = dlogitnorm,
    geom = "line",
    color= 'red',
    n=300,
    args = list(mu = 0, sigma = s),
    show.legend = T
  ) + 
  stat_function( # estimated params
    fun = dlogitnorm,
    geom = "line",
    color= 'white',
    n=300,
    args = list(mu = 0, sigma = est),
    show.legend = T
  ) + ylim(0,u) + ggtitle(t)  
  
  
  
  
  # return(cbind(est,div,c)) # uncomment if you want to estimates
  return(g)
}




```

# logitnorm sigma = 3.16
```{r}

s1<- est.calc( un, 3.16, 5, 'A) Uniform prior, true sigma = 3.16')
 s2<-est.calc( nor, 3.16,5, 'B) Norm prior,true sigma = 3.16')
# s3<- est.calc( bet, 3.16)
 s4<-est.calc( sn, 3.16, 5,'C) Skewnorm prior, true sigma = 3.16')
s1
```

# logitnorm with sigma = 1.78
```{r}
s5<-est.calc( un, 1.78,2, 'unif')
s6<-est.calc( nor, 1.78, 2, 'norm')
# s7<-est.calc( bet, 1.78)
s8<-est.calc(sn, 1.78, 2, 'skewnorm')
ss2<-ggarrange(s5,s6,s8, ncol = 2,nrow = 2)
annotate_figure(ss2, top = 'Estimated and true curves for sigma = 1.78')
```

#logitnorm sigma = .32
```{r}

s9<-est.calc( un, .32, 5, 'unif')
s10<-est.calc( nor, .32, 5,'norm')
# s11<-est.calc( bet, .32)
s12<-est.calc( sn, .32, 5, 'skewnrom')
ss3<-ggarrange(s9,s10,s12, ncol = 2,nrow = 2)
annotate_figure(ss3, top = 'Estimated and true curves for sigma = 0.32')
```

```{r}
sigma <- data.frame(rbind(s1,s2,s4,s5,s6,s8,s9,s10,s12))
# write.csv(sigma, 'sigmaestimates.csv')
sst <- ggarrange(s1,s2,s4,s5,s6,s8,s9,s10,s12, ncol = 3,nrow = 3)
annotate_figure(sst, top = 'Estimated and true curves for varying mu and fixed sigma')


```


# mu est function 
```{r}
est.mu <- function(prior, mu,u, t){
  set.seed(0)
  dat <- rlogitnorm(15000, mu, 1) 
  
  simps_three8 <- function(f, a, b, n){
  # function f
  # [a,b] interval of integration
  # n = number of BIG subdivisions (will be multiplied by three to include middle ones)
  nn = 3*n+1
  h = (b - a)/n
  xx <- seq(a, b, length=nn)
  y = f(xx)
  
  h*( y[1] + y[nn] + 3*sum(y[(2:(nn-1))[2:(nn-1)%%3!=1]])  + 2*sum(y[(2:(nn-1))[2:(nn-1)%%3==1]]) )/8
  }
  
  mu0 <- mean(dat)
  
  tests <- function (x){
  dlogitnorm(dat, x , 1)*prior(x)
  } 
  dnom <- simps_three8(tests, 0,1, 1000) 
  mu0 <- mean(dat)
  
  estm <- mean(((dlogitnorm(dat, mu, 1)*prior(mu0))/dnom))
  
   #KL Divergence
  truef <- plogitnorm(dat, mu, 1)
  samp <- plogitnorm(dat, estm,  1)
  mat <- rbind(truef/sum(truef) ,samp/sum(samp))
  div <- KL(mat)
  
  #CI
  simp <-rlogitnorm(15000, estm,1)
  c <- ci(simp, ci = .95, method = 'HDI', verbose =F)
  

  ex <- matrix(dat, ncol=1)

colnames(ex) <- "x"

g <-ggplot(as.data.frame(ex), aes(x=x)) + 
  geom_histogram(aes(y=..density..)) +
  stat_function( # orignal params
    fun = dlogitnorm,
    geom = "line",
    color= 'skyblue3',
    n=300,
    args = list(mu = mu, sigma = 1)
  ) + 
  stat_function( # estimated params
    fun = dlogitnorm,
    geom = "line",
    color= 'darkgoldenrod1',
    n=300,
    args = list(mu = estm, sigma = 1)
  ) + ylim(0,u) +ggtitle(t)
  
  
  # hist(dat, probability = T, ylim = c(0,5))
  # curve(dlogitnorm(x, mu, 1), col = 'red', add = T)
  # curve(dlogitnorm(x, estm, 1), col ='blue', add = T)
  # return(cbind(estm, div, c))
  return(g)
}



```

# mu = 0
```{r}
m1<-est.mu( un, 0,3, 'unif')
m2<-est.mu( nor, 0, 3, 'norm')
# m3<-est.mu( bet, 0)
m4<-est.mu( sn, 0, 3, 'skewnorm')

# mm1 <- ggarrange(m1,m2,m4, ncol = 2,nrow = 2)
# annotate_figure(mm1, top = 'Estimated and true curves for mu = 0')
```

# mu = 1
```{r}
m5<-est.mu( un, 1,3, 'unif')
m6<-est.mu( nor, 1, 3, 'norm')
# m7<-est.mu( bet, 1, )
m8<-est.mu( sn, 1,3, 'skewnorm')

# mm2 <-ggarrange(m5,m5,m8, ncol = 2,nrow = 2)
# annotate_figure(mm2, top = 'Estimated and true curves for mu = 1')
```

# mu = 2
```{r}
m9<-est.mu( un,  2,13, 'unif')
m10<-est.mu( nor, 2,13, 'norm')
# m11<-est.mu( bet, 2)
m12<- est.mu( sn,  2, 13, 'skewnorm')

# mm3 <-ggarrange(m9,m10,m12, ncol = 2,nrow = 2)
# annotate_figure(mm3, top = 'Estimated and true curves for mu = 2')
```


```{r}
mu<-data.frame(rbind(m1,m2,m4,m5,m6,m8,m9,m10,m12))
# write.csv(mu, 'muestimates.csv')
```


```{r}

mmt <- ggarrange(m1,m2,m4,m5,m6,m8,m9,m10,m12, ncol = 3,nrow = 3)
annotate_figure(mmt, top = 'Estimated and true curves for varying mu and fixed sigma')
```


```{r}
```


```{r}
```


```{r}
```


```{r}
```

